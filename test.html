<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>電工技能試験シミュレーター</title>

<style>
body {
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  background:#f8f8f8;
}

header {
  display:flex;
  justify-content:space-between;
  padding:12px 16px;
  background:white;
  box-shadow:0 2px 4px rgba(0,0,0,0.08);
}

button {
  background:#111;
  color:white;
  border:none;
  padding:8px 14px;
  border-radius:6px;
  cursor:pointer;
}

svg {
  background:white;
  display:block;
  margin:20px auto;
  box-shadow:0 2px 6px rgba(0,0,0,0.08);
}

.device {
  fill:white;
  stroke:black;
  stroke-width:2;
}

.terminal {
  fill:white;
  stroke:black;
  stroke-width:2;
  cursor:pointer;
}

.wire {
  stroke:black;
  stroke-width:3;
}

.live {
  stroke:#e60000 !important;
}
</style>
</head>
<body>

<header>
  <div>三路＋四路テスト回路</div>
  <div id="timer">00:00</div>
</header>

<svg id="board" width="800" height="400"></svg>

<div style="text-align:center;margin-bottom:20px;">
  <button onclick="check()">採点</button>
  <button onclick="resetBoard()">リセット</button>
</div>

<script>
/* ===============================
   Graph
================================*/
class Graph {
  constructor(){ this.edges = {}; }
  connect(a,b){
    if(!this.edges[a]) this.edges[a]=[];
    if(!this.edges[b]) this.edges[b]=[];
    if(!this.edges[a].includes(b)) this.edges[a].push(b);
    if(!this.edges[b].includes(a)) this.edges[b].push(a);
  }
}

/* ===============================
   Problem
================================*/
const problem = {
  power:{
    L:"breaker.L_out",
    N:"lamp.N"
  },
  devices:[
    {id:"breaker",type:"breaker",terminals:["L_in","L_out"]},
    {id:"sw1",type:"3way",terminals:["common","traveler1","traveler2"],state:0},
    {id:"sw2",type:"4way",terminals:["in1","in2","out1","out2"],state:0},
    {id:"sw3",type:"3way",terminals:["common","traveler1","traveler2"],state:0},
    {id:"lamp",type:"lamp",terminals:["L","N"]}
  ],
  rules:{ oneHoleOneWire:true, detectShort:true }
};

/* ===============================
   Engine
================================*/
class Engine{
  constructor(problem){
    this.problem=problem;
    this.graph=new Graph();
    this.userConnections=[];
  }

  rebuild(){
    this.graph=new Graph();
    for(const [a,b] of this.userConnections){
      this.graph.connect(a,b);
    }
    this.applyInternal();
  }

  applyInternal(){
    for(const d of this.problem.devices){

      if(d.type==="3way"){
        const c=`${d.id}.common`;
        const t1=`${d.id}.traveler1`;
        const t2=`${d.id}.traveler2`;
        this.graph.connect(c, d.state===0?t1:t2);
      }

      if(d.type==="4way"){
        const i1=`${d.id}.in1`;
        const i2=`${d.id}.in2`;
        const o1=`${d.id}.out1`;
        const o2=`${d.id}.out2`;
        if(d.state===0){
          this.graph.connect(i1,o1);
          this.graph.connect(i2,o2);
        }else{
          this.graph.connect(i1,o2);
          this.graph.connect(i2,o1);
        }
      }
    }
  }

  dfs(a,target,visited=new Set()){
    if(a===target) return true;
    visited.add(a);
    const neighbors=this.graph.edges[a]||[];
    for(const n of neighbors){
      if(!visited.has(n)){
        if(this.dfs(n,target,visited)) return true;
      }
    }
    return false;
  }

  isLampOn(){
    return this.dfs(problem.power.L,"lamp.L") &&
           !this.dfs(problem.power.L,problem.power.N);
  }
}

const engine=new Engine(problem);

/* ===============================
   Storage
================================*/
class StorageManager{
  constructor(){ this.key="denko_data"; }
  save(data){ localStorage.setItem(this.key,JSON.stringify(data)); }
  load(){ return JSON.parse(localStorage.getItem(this.key)||"{}"); }
}
const storage=new StorageManager();

/* ===============================
   UI
================================*/
const svg=document.getElementById("board");
let selected=null;

function addTerminal(x,y,id){
  const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
  c.setAttribute("cx",x);
  c.setAttribute("cy",y);
  c.setAttribute("r",6);
  c.setAttribute("class","terminal");
  c.dataset.terminal=id;
  c.onclick=terminalClick;
  svg.appendChild(c);
}

function terminalClick(e){
  const id=e.target.dataset.terminal;
  if(!selected){
    selected=id;
  }else{
    engine.userConnections.push([selected,id]);
    selected=null;
    engine.rebuild();
    render();
  }
}

function drawWire(a,b,live){
  const A=document.querySelector(`[data-terminal="${a}"]`);
  const B=document.querySelector(`[data-terminal="${b}"]`);
  if(!A||!B)return;
  const x1=A.getAttribute("cx");
  const y1=A.getAttribute("cy");
  const x2=B.getAttribute("cx");
  const y2=B.getAttribute("cy");

  const line=document.createElementNS("http://www.w3.org/2000/svg","line");
  line.setAttribute("x1",x1);
  line.setAttribute("y1",y1);
  line.setAttribute("x2",x2);
  line.setAttribute("y2",y2);
  line.setAttribute("class","wire"+(live?" live":""));
  svg.appendChild(line);
}

function render(){
  document.querySelectorAll(".wire").forEach(e=>e.remove());
  for(const [a,b] of engine.userConnections){
    drawWire(a,b,false);
  }
  if(engine.isLampOn()){
    document.querySelectorAll(".wire").forEach(w=>w.classList.add("live"));
  }
}

function resetBoard(){
  engine.userConnections=[];
  engine.rebuild();
  render();
}

/* ===============================
   初期配置
================================*/
addTerminal(100,200,"breaker.L_out");
addTerminal(200,150,"sw1.common");
addTerminal(200,250,"sw1.traveler1");
addTerminal(200,300,"sw1.traveler2");

addTerminal(350,200,"sw2.in1");
addTerminal(350,250,"sw2.in2");
addTerminal(450,200,"sw2.out1");
addTerminal(450,250,"sw2.out2");

addTerminal(600,150,"sw3.common");
addTerminal(600,250,"sw3.traveler1");
addTerminal(600,300,"sw3.traveler2");

addTerminal(750,200,"lamp.L");
addTerminal(750,250,"lamp.N");

engine.rebuild();
</script>

</body>
</html>
